package sql;

import java_cup.runtime.*;
import ast.*;

parser code {:

private boolean errores=false;

/***********
SymbolFactory es una nueva caracteristica que ha sido a�adida a las version 11a de cup, la cual facilita la implementacion de clases Symbol personalizadas
, esto debido a que dicha clase no provee mucha informaci�n de contexto que podria ser util para el analisis semantico o ayudar en la construccion del AST
Mas informacion en: http//4thmouse.com/index.php/2007/02/15/using-custom-symbols-in-cup/

esta version si sirveeeeeeeeeeeeeeeeeeee joel actual
***********/
	public static void main(String args[]) throws Exception {
				DefaultSymbolFactory sf = new DefaultSymbolFactory();
		
		parser parser_obj=null; 
		Scanner lexico; 
	 
	   
		
		  lexico = new Scanner(new java.io.FileInputStream("ejemplo_fuente/ejemplo_enunciado.c"),sf);
		  parser_obj=new parser(lexico,sf);
		  parser_obj.parse();
          if(!lexico.error())
          {
  			System.out.println("Analisis Lexico sin errores.");

      	     
      		if(!parser_obj.gethayerrores()){	
      		System.out.println("Analisis Sintactico sin errores.");
	        NodoBase root=parser_obj.action_obj.getASTroot();
			System.out.println();
			System.out.println("---------------------- Impresion de AST ----------------------");
			System.out.println();
			ast.Util.imprimirAST(root);
			TablaSimbolos ts = new TablaSimbolos();
			ts.cargarTabla(root);
			ts.ImprimirClaves();
			
				if(!ts.geterror()){	
					
						sql.Generador.setTablaSimbolos(ts);
						sql.Generador.generarCodigoObjeto(root);
					}   
				else
				{	System.err.println("\n\nErrores encontrados en analisis semantico.\n");
					
					for(int i=0;i<ts.errores.size();i++)
						System.err.println(ts.errores.get(i));
					System.err.println("\nNo se puede continuar con la generacion de codigo.");
      		        
      		      }  	
      		    }
    		else
    		{	System.err.println("Errores encontrados en analisis sintactico.");
      		    System.err.println("No se puede continuar con la generacion de codigo.");
    		}
          }
          else
          {  System.err.println("\n\nErrores encontrados en analisis lexico/sintactico/semantico.");
          System.err.println("No se puede continuar con la generacion de codigo.");
	    	
          }
		
		
		
		
	
	
	} 


	public boolean gethayerrores(){
		return errores;
	}
	
   
	public void syntax_error(Symbol s){
		System.err.println("[ERROR sintactico] token:" + s.value+" inesperado, Linea:"+(s.right+1) +" Columna:"+s.left+ "" );
		errores=true;
	}

	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
		System.err.println("[ERROR sintactico] token:" + s.value+" inesperado, Linea:"+(s.right+1) +" Columna:"+s.left+ "" );
		errores=true; 
	}

:}

action code {:

	private boolean debug=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}	
:}

/* Simbolos Terminales */
terminal String ID;
terminal String NUM;
terminal TRUE;
terminal FALSE;
terminal EQ;
terminal LE;
terminal GE;
terminal LT;
terminal GT;
terminal DIFF;
terminal AND;
terminal OR;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal COLOM;
terminal SEMI;


/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase param_list;
non terminal NodoBase assign_stmt;
non terminal NodoBase exp_seq;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;



/* BLOQUE PRINCIPAL */

program     ::= stmt_seq:script 
					{: 
                                	
                	if(debug) System.out.println("\t regla INICIAR PROGRAMA"); 												                           
						ast = script;
					:}
;



stmt_seq    ::= stmt_seq:ini  stmt:sent	{: if(debug) System.out.println("\t regla secuencia de sentencias"); 
						
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							
							hijoActual.setHermanoDerecha(sent);
							RESULT=ini;
						}
						else{
							
							RESULT=sent;
						}
			:}

            | stmt:sent	{: 
            			
            			if(debug) System.out.println("\t regla secuencia de sentencias"); 
						RESULT=sent;				
			:}

;


stmt        ::= select_seq:sseq	
				{: 
					if(debug) 
						System.out.println("\t regla sentencia"); 
					
					RESULT = sseq;
				:}
            
            
            | error	
            	{: 
            		if(debug) 
            			System.out.println("\t Error en sentencia"); 
										
					RESULT=null;
				:}
;

select_seq    ::= select_seq:sseq  select_stmt:select	{: if(debug) System.out.println("\t regla secuencia de select"); 
						
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							
							hijoActual.setHermanoDerecha(select);
							RESULT=sseq;
						}
						else{
							
							RESULT=select;
						}
			:}

            | select_stmt:select	{: 
            			
            			if(debug) System.out.println("\t regla secuencia de select"); 
						RESULT=select;				
			:}

;


select_stmt        ::= SELECT select_cols:c FROM ID:tabla where:w order_by:o
				{: 
					if(debug) 
						System.out.println("\t regla sentencia"); 
					
					RESULT = sseq;
				:}
            
            
            | error	
            	{: 
            		if(debug) 
            			System.out.println("\t Error en select"); 
										
					RESULT=null;
				:}
;

where ::=
        /* empty */
      | WHERE exp_seq:b {: 
            		if(debug) 
            			System.out.println("\t regla where"); 
										
					RESULT=null;
				:}
      | error {: 
            		if(debug) 
            			System.out.println("\t Error en where"); 
										
					RESULT=null;
				:}
      ;


param_list		::= param_list:paramlist COLOM exp_seq:exp
						{: 
								    
							NodoBase hijoActual = paramlist;
							if(hijoActual !=null){
								while(hijoActual.TieneHermano()){
									hijoActual = hijoActual.getHermanoDerecha();
								}
								
								hijoActual.setHermanoDerecha(exp);
								RESULT=paramlist;

							}
							else{
								RESULT=exp;
							}

						:}
							
					| 

					exp_seq:exp 
						{:
						    RESULT=exp;
						:}
						
					
;


exp_seq		::= exp_seq:exI OR exp:exD	
				{:
					if(debug) 
						System.out.println("\t regla or");
				 	
				 	RESULT = new NodoOperacion(exI,tipoOp.or,exD);				
				:}

			| exp_seq:exI AND exp:exD 
				{:
					if(debug) 
						System.out.println("\t regla and");
						
					RESULT = new NodoOperacion(exI,tipoOp.and,exD);					
				:}

			| exp:sd 
				{:
				    RESULT=sd;
				:}
;

exp ::= 		exp:exI GT simple_exp:exD	
                    {: 
                    	if(debug) 
                			System.out.println("\t regla mayor que"); 
                     	RESULT = new NodoOperacion(exI,tipoOp.mayor,exD);
                    :} 
                
                | exp:exI LT simple_exp:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla menor que"); 
                     	
                     	RESULT = new NodoOperacion(exI,tipoOp.menor,exD);
                    :}
                
                | exp:exI LE simple_exp:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla menor o igual"); 
                     	
                     	RESULT = new NodoOperacion(exI,tipoOp.menorigual,exD);
                    :}
                
                | exp:exI GE simple_exp:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla mayor o igual"); 
                    	
                    	RESULT = new NodoOperacion(exI,tipoOp.mayorigual,exD);
                    :}
                
                | exp:exI EQ simple_exp:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla igual"); 
                        
                        RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
                    :}
                
                | exp:exI DIFF simple_exp:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla diferente"); 
                        
                        RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
                    :}

                | simple_exp:exI 	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla diferente"); 
                        
                        RESULT = exI;
                    :}
                                
;


simple_exp  ::= simple_exp:exI PLUS term:exD	
					{: 
						if(debug) 
							System.out.println("\t regla suma"); 
						
						RESULT = new NodoOperacion(exI,tipoOp.mas,exD);
					:}

				| simple_exp:exI MINUS term:exD	
					{: 
						if(debug) 
							System.out.println("\t regla resta"); 
						
						RESULT = new NodoOperacion(exI,tipoOp.menos,exD);
					:}

				| term:ex	
					{:
			 			if(debug) 
			 				System.out.println("\t regla expresion"); 

						RESULT=ex;
					:}
;

term        ::= term:exI TIMES factor:exD	
				{: 
					if(debug) 
						System.out.println("\t regla multiplicacion"); 
					
					RESULT = new NodoOperacion(exI,tipoOp.por,exD);
				:}
			| term:exI OVER factor:exD	
				{: 
					if(debug) 
						System.out.println("\t regla division"); 
					
					RESULT = new NodoOperacion(exI,tipoOp.entre,exD);
				:}
			| factor:exD	
				{: 
					if(debug) 
						System.out.println("\t regla factor"); 
					
					RESULT = exD;
				:}
;


factor  ::= LPAREN exp_seq:ex RPAREN	
			{:
			 	if(debug) 
			 		System.out.println("\t regla factor con parentesis"); 
				
				RESULT = ex;
			:}


		| NUM:valor	
			{: 
				if(debug) 
					System.out.println("\t regla es un numero"); 
					
				if(valor!=null){
					RESULT= new NodoValor(Integer.parseInt(valor));					
				}
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0005");
				}
			:}

		| ID:variable	
			{: 
				if(debug) System.out.println("\t regla es un ID"); 
				
				if(variable != null){
						RESULT= new NodoIdentificador(variable.toString());		
				}
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0005");
				}
			:} 

		|
		TRUE	
			{: 
				if(debug) 
					System.out.println("\t regla factor TRUE"); 
				
				System.out.println("Regla true");					
				RESULT= new NodoValor(true);										
			:}
		
		| FALSE 
			{: 
				if(debug) 
					System.out.println("\t regla factor FALSE"); 
				
				System.out.println("Regla false");					
				RESULT= new NodoValor(false);										
			:}		
                
		| error	
			{: 
				if(debug) 
					System.out.println("\t regla 12d"); 
				
				System.out.println("Ocurrio error en cup # 0003");
				RESULT=null;
			:}             
;