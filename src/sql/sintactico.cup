package sql;

import java_cup.runtime.*;
import ast.*;

parser code {:

private boolean errores=true;

/***********
SymbolFactory es una nueva caracteristica que ha sido a�adida a las version 11a de cup, la cual facilita la implementacion de clases Symbol personalizadas
, esto debido a que dicha clase no provee mucha informaci�n de contexto que podria ser util para el analisis semantico o ayudar en la construccion del AST
Mas informacion en: http//4thmouse.com/index.php/2007/02/15/using-custom-symbols-in-cup/

esta version si sirveeeeeeeeeeeeeeeeeeee joel actual
***********/
	public static void main(String args[]) throws Exception {
				DefaultSymbolFactory sf = new DefaultSymbolFactory();
		
		parser parser_obj=null; 
		Scanner lexico; 
	 
	   
		
		  lexico = new Scanner(new java.io.FileInputStream("ejemplo_fuente/ejemplo_enunciado.c"),sf);
		  parser_obj=new parser(lexico,sf);
		  parser_obj.parse();
          if(!lexico.error())
          {
  			System.out.println("Analisis Lexico sin errores.");

      	     
      		if(!parser_obj.gethayerrores()){	
      		System.out.println("Analisis Sintactico sin errores.");
	        NodoBase root=parser_obj.action_obj.getASTroot();
			System.out.println();
			System.out.println("---------------------- Impresion de AST ----------------------");
			System.out.println();
			ast.Util.imprimirAST(root);
			TablaSimbolos ts = new TablaSimbolos();
			ts.cargarTabla(root);
			ts.ImprimirClaves();
			
				if(!ts.geterror()){	
					
						sql.Generador.setTablaSimbolos(ts);
						sql.Generador.generarCodigoObjeto(root);
					}   
				else
				{	System.err.println("\n\nErrores encontrados en analisis semantico.\n");
					
					for(int i=0;i<ts.errores.size();i++)
						System.err.println(ts.errores.get(i));
					System.err.println("\nNo se puede continuar con la generacion de codigo.");
      		        
      		      }  	
      		    }
    		else
    		{	System.err.println("Errores encontrados en analisis sintactico.");
      		    System.err.println("No se puede continuar con la generacion de codigo.");
    		}
          }
          else
          {  System.err.println("\n\nErrores encontrados en analisis lexico/sintactico/semantico.");
          System.err.println("No se puede continuar con la generacion de codigo.");
	    	
          }
		
		
		
		
	
	
	} 


	public boolean gethayerrores(){
		return errores;
	}
	
   
	public void syntax_error(Symbol s){
		System.err.println("[ERROR sintactico] token:" + s.value+" inesperado, Linea:"+(s.right+1) +" Columna:"+s.left+ "" );
		errores=true;
	}

	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
		System.err.println("[ERROR sintactico] token:" + s.value+" inesperado, Linea:"+(s.right+1) +" Columna:"+s.left+ "" );
		errores=true; 
	}

:}

action code {:

	private boolean debug=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}	
:}

/* Simbolos Terminales */
terminal SELECT;
terminal FROM;
terminal WHERE; 
terminal JOIN;
terminal ON;
terminal AND;
terminal OR;
terminal COLOM;
terminal EQUAL;
terminal NOT_EQUAL;
terminal SEMI;
terminal DOT;
terminal ALL;
terminal QUOTES;
terminal String NUM;
terminal String ID;
terminal TRUE;
terminal FALSE;

/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase select_stmt;
non terminal NodoBase stmt_seq;
non terminal NodoBase where;
non terminal NodoBase param_list;
non terminal NodoBase exp_seq;
non terminal NodoBase exp;
non terminal NodoBase factor;



/* BLOQUE PRINCIPAL */

program     ::= stmt_seq:script 
					{: 
                                	
                	if(debug) System.out.println("\t regla INICIAR SQL"); 												                           
						ast = script;
					:}
;



stmt_seq    ::= stmt_seq:ini select_stmt:sent	{: if(debug) System.out.println("\t regla secuencia de sentencias"); 
						
						NodoBase hijoActual = ini;
						if(hijoActual !=null){
							
							while(hijoActual.TieneHermano()){
								hijoActual = hijoActual.getHermanoDerecha();
							}
							
							hijoActual.setHermanoDerecha(sent);
							RESULT=ini;
						}
						else{
							
							RESULT=sent;
						}
			:}

            | select_stmt:sent	SEMI {: 
            			
            			if(debug) System.out.println("\t regla sentencia de select"); 
						RESULT=sent;				
			:}

;


//select * from employees JOIN departamento ON employee.departamento=departamento.id where employee_id = 1;


select_stmt        ::= SELECT param_list:c FROM ID:tabla where:w
				{: 
					if(debug) 
						System.out.println("\t regla select"); 
					
					//RESULT = new Select(c, w);
				:}

			|

				SELECT param_list:columnas FROM ID:tabla JOIN ID:tabla2 ON ID:tablaJoin DOT ID:columna1 EQUAL ID:tabla2Join DOT ID:columna2 where:w
				{: 
					if(debug) 
						System.out.println("\t regla select con join de 1 tabla"); 
					
					//RESULT = new Select();
				:}

			|

				SELECT param_list:columnas FROM ID:tabla JOIN ID:tabla2 ON ID:tabla DOT ID:columna1 EQUAL ID:tabla2 DOT ID:columna2 JOIN ID:tabla3 ON ID:tabla DOT ID:columna3 EQUAL ID:tabla3 DOT ID:columna4 where:w
				{: 
					if(debug) 
						System.out.println("\t regla select con join de 2 tablas"); 
					
					//RESULT = new Select();
				:}

            
           
;

where ::=
        /* empty */
      | WHERE exp_seq:b {: 
            		if(debug) 
            			System.out.println("\t regla where"); 
										
					RESULT=null;
				:}
     
      ;


param_list		::= param_list:paramlist COLOM ID:col
						{: 
								    
							NodoBase hijoActual = paramlist;
							if(hijoActual !=null){
								while(hijoActual.TieneHermano()){
									hijoActual = hijoActual.getHermanoDerecha();
								}
								
								hijoActual.setHermanoDerecha(exp);
								RESULT=paramlist;

							}
							else{
								RESULT=col;
							}

						:}
							
					| 

					ID:col
						{:
						    RESULT=col;
						:}
					|

					ALL:todo {:
						RESULT = todo;
					:}
						
					
;


exp_seq		::= exp_seq:exI OR exp:exD	
				{:
					if(debug) 
						System.out.println("\t regla or");
				 	
				 	//RESULT = new NodoOperacion(exI,tipoOp.or,exD);				
				:}

			| exp_seq:exI AND exp:exD 
				{:
					if(debug) 
						System.out.println("\t regla and");
						
					//RESULT = new NodoOperacion(exI,tipoOp.and,exD);					
				:}

			| exp:sd 
				{:
				    //RESULT=sd;
				:}
;

exp ::= 	 	exp:exI EQUAL factor:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla igual"); 
                        
                        //RESULT = new NodoOperacion(exI,tipoOp.igual,exD);
                    :}
                
                | exp:exI NOT_EQUAL factor:exD	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla diferente"); 
                        
                        //RESULT = new NodoOperacion(exI,tipoOp.diferente,exD);
                    :}

                | factor:fac 	
                    {: 
                    	if(debug) 
                    		System.out.println("\t regla diferente"); 
                        
                        //RESULT = exI;
                    :}
                                
;

factor  ::= NUM:valor	
			{: 
				if(debug) 
					System.out.println("\t regla es un numero"); 
					
				if(valor!=null){
					RESULT= new NodoValor(Integer.parseInt(valor));					
				}
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0005");
				}
			:}

		| ID:variable	
			{: 
				if(debug) System.out.println("\t regla es un ID"); 
				
				if(variable != null){
						RESULT= new NodoIdentificador(variable.toString());		
				}
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0005");
				}
			:}
		| QUOTES ID:nombre QUOTES 
			{: 
				if(debug) System.out.println("\t regla es un ID entre QUOTES"); 
				
				if(variable != null){
						RESULT= new NodoIdentificador(nombre.toString());		
				}
				else{
					RESULT = null;
					System.out.println("Ocurrio error en cup # 0005");
				}
			:}
		|
		TRUE	
			{: 
				if(debug) 
					System.out.println("\t regla factor TRUE"); 
				
				System.out.println("Regla true");					
				RESULT= new NodoValor(true);										
			:}
		
		| FALSE 
			{: 
				if(debug) 
					System.out.println("\t regla factor FALSE"); 
				
				System.out.println("Regla false");					
				RESULT= new NodoValor(false);										
			:}		
                
		| error	
			{: 
				if(debug) 
					System.out.println("\t regla 12d"); 
				
				System.out.println("Ocurrio error en cup # 0003");
				RESULT=null;
			:}             
;